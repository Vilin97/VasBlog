<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/basic.css"> <link rel=icon  href="/assets/favicon.png"> <title>Towards the second PR</title> <header> <div class=blog-name ><a href="">VasBlog</a></div> <nav> <ul> <li><a href="/">Home</a> <li><a href="/about/">About Me</a> <li><a href="/posts/">Blog</a> <li><a href="/menu3/">Test</a> </ul> <img src="/assets/hamburger.svg" id=menu-icon > </nav> </header> <div class=franklin-content > <h1 id=towards_the_second_pr ><a href="#towards_the_second_pr" class=header-anchor >Towards the second PR</a></h1> <p>In the <a href="/posts/post2/">previous post</a> I described the Next Subvolume Method. Once that PR was merged, I wrote an <a href="https://github.com/SciML/DiffEqJump.jl/issues/189">issue</a> outlining what needs to be done next. My <a href="https://github.com/SciML/DiffEqJump.jl/pull/192">next PR</a> will complete the top 6 TODOs on the list. Most importantly, it introduces more comprehensive tests and three optimized <code>CartesianGrid</code> structs.</p> <h2 id=improving_the_tests ><a href="#improving_the_tests" class=header-anchor >Improving the tests</a></h2> <p>The previous PR only tested the NSM on 1D grids, which left room for bugs to go undetected. In this PR I added a way to test pure diffusion on arbitrary graphs. First, given a graph and a hopping rate &#40;probability per time of hopping to a neighboring site&#41; we must contruct the <a href="https://en.wikipedia.org/wiki/Laplacian_matrix">discrete Laplacian</a> matrix <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span>. The following function does that.</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> discrete_laplacian_from_spatial_system(spatial_system, hopping_rate)
    sites = <span class=hljs-number >1</span>:DiffEqJump.num_sites(spatial_system)
    laplacian = zeros(<span class=hljs-built_in >Int</span>, length(sites), length(sites))
    <span class=hljs-keyword >for</span> site <span class=hljs-keyword >in</span> sites
        laplacian[site,site] = -DiffEqJump.num_neighbors(spatial_system, site)
        <span class=hljs-keyword >for</span> nb <span class=hljs-keyword >in</span> DiffEqJump.neighbors(spatial_system, site)
            laplacian[site, nb] = <span class=hljs-number >1</span>
        <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >end</span>
    laplacian*hopping_rate
<span class=hljs-keyword >end</span></code></pre> <p>We now have the system of differential equations <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mi>L</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">\frac{dy}{dt} = Ly</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.277216em;vertical-align:-0.345em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class=pstrut  style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">t</span></span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class=pstrut  style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo stretchy=false >[</mo><mi>s</mi><mo stretchy=false >]</mo><mo stretchy=false >(</mo><mi>t</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">y[s](t)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=mopen >[</span><span class="mord mathnormal">s</span><span class=mclose >]</span><span class=mopen >(</span><span class="mord mathnormal">t</span><span class=mclose >)</span></span></span></span> is the expected number of species <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> at time <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>. The solution is given by <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo stretchy=false >(</mo><mi>t</mi><mo stretchy=false >)</mo><mo>=</mo><msup><mi>e</mi><mrow><mi>L</mi><mi>t</mi></mrow></msup></mrow><annotation encoding="application/x-tex">y(t) = e^{Lt}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=mopen >(</span><span class="mord mathnormal">t</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.8413309999999999em;vertical-align:0em;"></span><span class=mord ><span class="mord mathnormal">e</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span></span>, which is computed by the following script.</p> <pre><code class="julia hljs">lap = discrete_laplacian_from_spatial_system(LightGraphs.grid(dims), hopping_rate)
evals, B = eigen(lap) <span class=hljs-comment ># lap == B*diagm(evals)*B&#x27;</span>
Bt = B&#x27;
analytic_solution(t) = B*diagm(<span class=hljs-literal >ℯ</span>.^(t*evals))*Bt * reshape(prob.u0, num_nodes, <span class=hljs-number >1</span>)</code></pre> <p>A neat fact from linear algebra is that a symmetric matrix is always diagonalizable, and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> is symmetric. So the procedure above will always work.</p> <p>By the weak law of large numbers we know that the average of many simulations should converge to the expected value, which is what we test.</p> <pre><code class="julia hljs">Nsims = <span class=hljs-number >10000</span>
rel_tol = <span class=hljs-number >0.01</span>
grids = [DiffEqJump.CartesianGrid1(dims), DiffEqJump.CartesianGrid2(dims), DiffEqJump.CartesianGrid3(dims), LightGraphs.grid(dims)]
<span class=hljs-keyword >for</span> grid <span class=hljs-keyword >in</span> grids
    spatial_jump_prob = JumpProblem(prob, alg, majumps, hopping_constants=hopping_constants, spatial_system=grid, save_positions=(<span class=hljs-literal >false</span>,<span class=hljs-literal >false</span>)) <span class=hljs-comment >#set up the jump problem</span>
    mean_sol = get_mean_sol(spatial_jump_prob, Nsims, tf/num_time_points) <span class=hljs-comment ># average of 10000 runs</span>
    <span class=hljs-keyword >for</span> (i,t) <span class=hljs-keyword >in</span> enumerate(times)
        <span class=hljs-keyword >local</span> diff = analytic_solution(t) - reshape(mean_sol[i], num_nodes, <span class=hljs-number >1</span>)
        <span class=hljs-meta >@test</span> abs(sum(diff[<span class=hljs-number >1</span>:center_node])/sum(analytic_solution(t)[<span class=hljs-number >1</span>:center_node])) &lt; rel_tol
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span></code></pre> <h2 id=optimizing_cartesian_grid ><a href="#optimizing_cartesian_grid" class=header-anchor >Optimizing Cartesian grid</a></h2> <p>A 3 by 3 Cartesian grid:</p> <table><tr><th align=right ><th align=right ><th align=right ><tr><td align=right >1<td align=right >4<td align=right >7<tr><td align=right >2<td align=right >5<td align=right >8<tr><td align=right >3<td align=right >6<td align=right >9</table> <p>A frequent use-case for spatial SSAss is to do simulation on a 1D, 2D or 3D rectangular grid in Euclidean space. For example, we might want be interested in some molecule diffusing on a small patch of a cell&#39;s membrane, which is basically a two-dimensional rectangle. While this is a special case of a graph, it is common enough to implement it separately and efficiently. I implemented three versions of a Cartesian grid in <a href="https://github.com/Vilin97/DiffEqJump.jl/blob/spatial_experiments/src/spatial/utils.jl">utils.jl</a>. The most important function required of a graph or a Cartesian grid is <code>rand_nbr&#40;grid, site&#41;</code>, which outputs a random neighbor of <code>site</code> with uniform probability. For an arbitrary graph it is simply </p> <pre><code class="julia hljs">rand_nbr(graph::AbstractGraph, site) = rand(neighbors(graph, site))</code></pre>
<p>where <code>neighbors&#40;graph, site&#41;</code> is a pre-computed list of neighbors.</p>
<p>For a Cartesian grid there is no need to pre-compute the list of neighbors for each site because of strong regularity of the neighbor list. For example, in a 2D grid, each site has 4 neighbors &#40;up, down, left, right&#41; except those neighbors that are outside the grid. For example, site 4 has neighbors 1, 7, and 5. In a <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mo>×</mo><mn>100</mn><mo>×</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">100 \times 100 \times 100</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.72777em;vertical-align:-0.08333em;"></span><span class=mord >100</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.72777em;vertical-align:-0.08333em;"></span><span class=mord >100</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >100</span></span></span></span> grid, we would need an array of length <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">10^6</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8141079999999999em;vertical-align:0em;"></span><span class=mord >1</span><span class=mord ><span class=mord >0</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span> to store the list of all neighbors, which is not cache-friendly. So what are the alternatives to pre-computing all neighbors?</p>
<p>We can rejection-sample a neighbor in the following fashion. Given a site, assume that it has all 4 &#40;or 6 in case of 3D&#41; neighbors and pick a random one. If it is inside the grid, we have our neighbor. Otherwise, do the same thing again. Since most sites have all 4 &#40;6&#41;neighbors, the probability of having to try again is small. This turns out to be the fastest sampling method for large grids, according to my benchmarking.</p>
<p>We can sample a neighbor by iterating. Pre-compute the number of neighbors for each site, and given a site, draw a random number from 1 to the number of neighbors of the site. Then iterate to that neighbor, discarding those potential neighbors that are outside the grid.</p>
<p>In order to find out which method &#40;pre-computing neighbors, rejection-sampling or iteration-sampling&#41; is the fastest I imlpemented three version of a Cartesian grid and benchmarked them. The rejection-sampling method came out to be the winner for larger &#40;<span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>64</mn><mo>×</mo><mn>64</mn><mo>×</mo><mn>64</mn></mrow><annotation encoding="application/x-tex">64\times 64 \times 64</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.72777em;vertical-align:-0.08333em;"></span><span class=mord >64</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.72777em;vertical-align:-0.08333em;"></span><span class=mord >64</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >64</span></span></span></span>&#41; grids.</p>

<figure>
  <img src="/assets/diffusion_bench.png" width="100%" />
  <figcaption> Simulation of the DNA repressor model. </figcaption>
</figure>

<h2 id=further_work ><a href="#further_work" class=header-anchor >Further work</a></h2>
<p>The next step is to add support of various forms of hopping rates. Currently, the assumption is that hopping rates are of form <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mrow><mi>s</mi><mo separator=true >,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">D_{s,i}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.969438em;vertical-align:-0.286108em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> is a species and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> is a site &#40;i.e. hopping rates depend only on the species and site&#41;. Other common forms of hopping rates include <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mrow><mi>s</mi><mo separator=true >,</mo><mi>i</mi><mo separator=true >,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_{s,i,j}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.969438em;vertical-align:-0.286108em;"></span><span class=mord ><span class="mord mathnormal">L</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>s</mi></msub><mo>⋅</mo><msub><mi>L</mi><mrow><mi>i</mi><mo separator=true >,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">D_s \cdot L_{i,j}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.83333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >⋅</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.969438em;vertical-align:-0.286108em;"></span><span class=mord ><span class="mord mathnormal">L</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>, and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mrow><mi>s</mi><mo separator=true >,</mo><mi>i</mi></mrow></msub><mo>⋅</mo><msub><mi>L</mi><mrow><mi>i</mi><mo separator=true >,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">D_{s,i}\cdot L_{i,j}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.969438em;vertical-align:-0.286108em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.286108em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >⋅</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.969438em;vertical-align:-0.286108em;"></span><span class=mord ><span class="mord mathnormal">L</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>. Each of these is a special case of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mrow><mi>s</mi><mo separator=true >,</mo><mi>i</mi><mo separator=true >,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_{s,i,j}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.969438em;vertical-align:-0.286108em;"></span><span class=mord ><span class="mord mathnormal">L</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>, so implementing this is the priority, but each special case allows for more efficient memory usage and thus better performance.</p>
<p>At the moment there are two data main structures used in spatial simulation: <code>AbstractSpatialSystem</code> and <code>AbstractSpatialRates</code>. The role of the first is to contain all information about the topology &#40;number of sites, number of neighbors for each site, sampling a random neighbor&#41;. The role of the second is to contain all information about the current rates of reactions and jumps. In order to improve orthogonality <code>AbstractSpatialRates</code> can be split into <code>AbstractRxRates</code> and <code>AbstractHoppingRates</code>. Depending on the form that hopping or reaction rates take, the user will pass in different objects, making it easy to &quot;assemble&quot; the spatial simulation.</p>
<div class=page-foot >
  <div class=copyright >
    &copy; Vasily Ilin. Last modified: July 16, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>